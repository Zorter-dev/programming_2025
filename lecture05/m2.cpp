/*
#include <iostream>
using namespace std;

void f1(int b[]){
	cout << "hello from f1:\t" << sizeof(b) << '\t' << b << endl;
}
void f2(int* b){
	cout << "hello from f2:\t" << sizeof(b) << '\t' << b << endl;
}

int main() {
	int a[]{1, 2, 3, 4, 5};
	// --------------- A ---------------
	cout << "\n\na)\n";
	cout << a       << '\n'; // адрес первого элемента
	cout << a+1     << '\n'; // на sizeof(int) больше чем предыдущая
	cout << &(a[1]) << '\n'; // то же что предыдущая строчка
	
	// --------------- B ---------------
	cout << "\nb)\n";
	cout << a[1]    << '\n'; // оператор [] - синтаксический сахар для адресной арифметики
	cout << 1[a]    << '\n'; // орератор [] коммутативен
	cout << *(a+1)  << '\n'; // чистая адресная арифметика
	
	// --------------- C ---------------
	// тоже самое, но с указателем
	int* a_ptr = a; // эквивалентно &a[0]
	cout << "\nc)\n";
	cout << sizeof(a) <<'\t'<< sizeof(a_ptr) << '\n'; // не путаем указатели и массивы - это разные объекты
	cout << a         <<'\t'<< a_ptr         << '\n'; // хотя у них и одинаковые адреса
	f1(a); // при передаче в функцию - передается адрес!!!
	f2(a); // то есть его можно "ловить" в указатель(но чаще всего не нужно)
	
	// --------------- D ---------------
	cout << "\nd)\n";
	cout << a_ptr[1]   << '\n'; // работает так же как для массива
	cout << 1[a_ptr]   << '\n';
	cout << *(a_ptr+1) << '\n';
	
	// --------------- E ---------------
	// и еще забавная штука:
	int x = 6, y = 7, z = 8; // большинство компиляторов выделит память для этих переменных друг за другом.
	int* b = &x; // так что можно попытаться обращаться к ним, как к элементам массива
	cout << "\ne)\n" << b[0] <<'\t'<< b[1] <<'\t'<< b[2] << endl;
	// но так делать нельзя, так как это undefined behavior (UB) и если разработчик компилятора че-то там наоптимизировал, то мы залезем за пределы памяти своей программы и получим по шапке от операционной системы или вообще что угодно произойти может
	return 0;
}
*/